<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARG - Prueba de Fondo Parallax</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@700&display=swap" rel="stylesheet">
    
    <style>
        * { box-sizing: border-box; }

        body {
            margin: 0;
            /* Le damos una altura muy grande para poder hacer scroll y ver el efecto */
            height: 500vh; 
            background-color: #1a1a1a;
            overflow-x: hidden;
        }

        /* 
         El contenedor principal del fondo.
         Es fijo, así que se queda quieto mientras el body se desplaza.
        */
        .parallax-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh; /* Ocupa toda la pantalla */
            overflow: hidden; /* Evita que los elementos al moverse generen barras de scroll */
            z-index: -1; /* Se asegura de que esté detrás de todo */
        }

        /* 
         Cada imagen o video individual en el fondo.
         Se posicionan de forma absoluta para crear el collage.
        */
        .parallax-element {
            position: absolute;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            overflow: hidden;
            /* La magia del movimiento la controla el JavaScript con 'transform' */
            will-change: transform;
        }

        .parallax-element img,
        .parallax-element video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Asegura que el medio llene el contenedor sin deformarse */
            display: block;
        }

    </style>
</head>
<body>

    <!-- 
      Este es nuestro lienzo. Contiene todos los elementos multimedia
      que se moverán a diferentes velocidades.
    -->
    <div class="parallax-background">

        <!-- Fila 1: img01.png -->
        <div class="parallax-element" 
             data-speed="-0.3" 
             style="top: 5%; left: 10%; width: 80vw; height: 35vh;">
            <img src="assets/img/img01.png" alt="Fondo 1">
        </div>

        <!-- Fila 2: skin02.webm -->
        <div class="parallax-element" 
             data-speed="-0.5" 
             style="top: 45%; left: 5%; width: 90vw; height: 30vh;">
            <video src="assets/vid/skin02.webm" autoplay loop muted playsinline></video>
        </div>
        
        <!-- Fila 3, Izquierda: img02.png -->
        <div class="parallax-element" 
             data-speed="-0.2" 
             style="top: 80%; left: 2%; width: 45vw; height: 40vh;">
            <img src="assets/img/img02.png" alt="Fondo 2">
        </div>
        
        <!-- Fila 3, Derecha: skin03.webm (usé el 03 que tenías, si es 04 lo cambias) -->
        <div class="parallax-element" 
             data-speed="-0.6" 
             style="top: 85%; left: 50%; width: 48vw; height: 30vh;">
            <video src="assets/vid/skin03.webm" autoplay loop muted playsinline></video>
        </div>

        <!-- Fila 4: fondo01.webm -->
        <div class="parallax-element" 
             data-speed="-0.35" 
             style="top: 120%; left: 15%; width: 70vw; height: 40vh;">
            <video src="assets/vid/fondo01.webm" autoplay loop muted playsinline></video>
        </div>

    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const parallaxElements = document.querySelectorAll('.parallax-element');
            let ticking = false;

            function updateParallax() {
                const scrollY = window.pageYOffset;

                parallaxElements.forEach(element => {
                    // La velocidad es negativa para el efecto INVERSO (al bajar, el fondo sube)
                    const speed = parseFloat(element.dataset.speed);
                    const yPos = scrollY * speed;
                    
                    element.style.transform = `translateY(${yPos}px)`;
                });

                ticking = false;
            }

            window.addEventListener('scroll', () => {
                // Usamos requestAnimationFrame para optimizar el rendimiento y evitar lag
                if (!ticking) {
                    window.requestAnimationFrame(updateParallax);
                    ticking = true;
                }
            });
            
            // Llamamos a la función una vez al inicio para posicionar todo correctamente
            updateParallax();
        });
    </script>
</body>
</html>
